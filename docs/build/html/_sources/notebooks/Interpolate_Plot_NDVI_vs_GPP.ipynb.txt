{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Load the netcdf, interpolate pixel to pixel"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import xarray as xr\n",
    "\n",
    "df = xr.open_dataset('NDVI_FSW.netcdf')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df.keys()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df['time']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import xarray as xr\n",
    "import numpy as np\n",
    "import plotly.graph_objects as go\n",
    "\n",
    "# Load the NetCDF file\n",
    "file_path = 'NDVI_FSW.netcdf'  # Update path if needed\n",
    "\n",
    "ds = xr.open_dataset(file_path)\n",
    "\n",
    "# Extract NDVI and coordinates\n",
    "ndvi = ds[\"NDVI\"]\n",
    "times = ds[\"time\"].values\n",
    "x_coords = ds[\"x\"].values\n",
    "y_coords = ds[\"y\"].values\n",
    "\n",
    "# Create frames for the animation\n",
    "frames = []\n",
    "for i, t in enumerate(times):\n",
    "    frames.append(go.Frame(\n",
    "        data=[go.Heatmap(\n",
    "            z=ndvi[i].values,\n",
    "            x=x_coords,\n",
    "            y=y_coords,\n",
    "            colorscale='Viridis',\n",
    "            zmin=-1,\n",
    "            zmax=1,\n",
    "            colorbar=dict(title='NDVI')\n",
    "        )],\n",
    "        name=str(np.datetime_as_string(t, unit='D'))\n",
    "    ))\n",
    "\n",
    "# Create the base figure\n",
    "fig = go.Figure(\n",
    "    data=frames[0].data,\n",
    "    layout=go.Layout(\n",
    "        title='NDVI Heatmap Over Time',\n",
    "        updatemenus=[dict(\n",
    "            type='buttons',\n",
    "            showactive=False,\n",
    "            buttons=[dict(label='Play',\n",
    "                          method='animate',\n",
    "                          args=[None, dict(frame=dict(duration=200, redraw=True),\n",
    "                                           fromcurrent=True, mode='immediate')])]\n",
    "        )],\n",
    "        sliders=[dict(\n",
    "            steps=[dict(method='animate',\n",
    "                        args=[[f.name], dict(mode='immediate',\n",
    "                                             frame=dict(duration=200, redraw=True),\n",
    "                                             fromcurrent=True)],\n",
    "                        label=f.name) for f in frames],\n",
    "            x=0.1,\n",
    "            xanchor=\"left\",\n",
    "            y=0,\n",
    "            yanchor=\"top\"\n",
    "        )]\n",
    "    ),\n",
    "    frames=frames\n",
    ")\n",
    "\n",
    "fig.update_layout(\n",
    "    xaxis_title=\"X Coordinate\",\n",
    "    yaxis_title=\"Y Coordinate\"\n",
    ")\n",
    "\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import xarray as xr\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import plotly.graph_objects as go\n",
    "\n",
    "# Load the NDVI data\n",
    "ds = xr.open_dataset(\"NDVI_HW_2022_23.netcdf\")\n",
    "ndvi = ds[\"NDVI\"].load()\n",
    "\n",
    "# Two-step interpolation\n",
    "new_times = pd.date_range(\"2022-09-23 00:00:00\", \"2023-12-31 23:30:00\", freq=\"30min\")\n",
    "\n",
    "\n",
    "# Interpolate and fill\n",
    "ndvi_pixel_interp = ndvi.interp(time=new_times, method=\"linear\")\n",
    "ndvi_interp_full = ndvi_pixel_interp.ffill(\"time\").bfill(\"time\")\n",
    "\n",
    "# Extract coordinates and time\n",
    "x_coords = ndvi_interp_full[\"x\"].values\n",
    "y_coords = ndvi_interp_full[\"y\"].values\n",
    "times = ndvi_interp_full[\"time\"].values\n",
    "\n",
    "# Sample every 48 time steps (i.e., 1 per day)\n",
    "sample_indices = np.arange(0, len(times), 48)\n",
    "\n",
    "# Create frames\n",
    "frames = []\n",
    "for i in sample_indices:\n",
    "    frames.append(go.Frame(\n",
    "        data=[go.Heatmap(\n",
    "            z=ndvi_interp_full[i].values,\n",
    "            x=x_coords,\n",
    "            y=y_coords,\n",
    "            colorscale='Viridis',\n",
    "            zmin=-1,\n",
    "            zmax=1,\n",
    "            colorbar=dict(title='NDVI')\n",
    "        )],\n",
    "        name=str(np.datetime_as_string(times[i], unit='D'))\n",
    "    ))\n",
    "\n",
    "# Create the figure\n",
    "fig = go.Figure(\n",
    "    data=frames[0].data,\n",
    "    layout=go.Layout(\n",
    "        title='NDVI Heatmap Over Time (Interpolated)',\n",
    "        updatemenus=[dict(\n",
    "            type='buttons',\n",
    "            showactive=False,\n",
    "            buttons=[dict(label='Play',\n",
    "                          method='animate',\n",
    "                          args=[None, dict(frame=dict(duration=200, redraw=True),\n",
    "                                           fromcurrent=True, mode='immediate')])]\n",
    "        )],\n",
    "        sliders=[dict(\n",
    "            steps=[dict(method='animate',\n",
    "                        args=[[f.name], dict(mode='immediate',\n",
    "                                             frame=dict(duration=200, redraw=True),\n",
    "                                             fromcurrent=True)],\n",
    "                        label=f.name) for f in frames],\n",
    "            x=0.1,\n",
    "            xanchor=\"left\",\n",
    "            y=0,\n",
    "            yanchor=\"top\"\n",
    "        )]\n",
    "    ),\n",
    "    frames=frames\n",
    ")\n",
    "\n",
    "fig.update_layout(\n",
    "    xaxis_title=\"X Coordinate\",\n",
    "    yaxis_title=\"Y Coordinate\"\n",
    ")\n",
    "\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ndvi_interp_full.to_netcdf('NDVI_HW_interpolated_30min_2022_23.netcdf')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ndvi_interp_full['y']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Tower position as reference (0,0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import xarray as xr\n",
    "from pyproj import Transformer\n",
    "\n",
    "# Load the NDVI dataset\n",
    "file_path = \"NDVI_HW_interpolated_30min_2022_23.netcdf\"  # Update this path if needed\n",
    "ds = xr.open_dataset(file_path)\n",
    "\n",
    "# Step 1: Extract original UTM x and y values\n",
    "x_vals = ds[\"x\"].values\n",
    "y_vals = ds[\"y\"].values\n",
    "\n",
    "# Step 2: Define reference point (latitude, longitude)\n",
    "ref_lat, ref_lon = 31.01651, -91.32409\n",
    "\n",
    "# Step 3: Convert reference lat/lon to UTM coordinates (Zone 15N)\n",
    "transformer = Transformer.from_crs(\"epsg:4326\", \"epsg:32615\", always_xy=True)\n",
    "ref_x, ref_y = transformer.transform(ref_lon, ref_lat)\n",
    "\n",
    "# Step 4: Compute relative distance from reference point (in meters)\n",
    "x_relative = x_vals - ref_x\n",
    "y_relative = y_vals - ref_y\n",
    "\n",
    "# Step 5: Add these new coordinates to the dataset\n",
    "ds = ds.assign_coords(x_meters_from_ref=(\"x\", x_relative))\n",
    "ds = ds.assign_coords(y_meters_from_ref=(\"y\", y_relative))\n",
    "\n",
    "# Optional: Inspect the new ranges\n",
    "print(\"X range (meters from ref):\", x_relative.min(), \"to\", x_relative.max())\n",
    "print(\"Y range (meters from ref):\", y_relative.min(), \"to\", y_relative.max())\n",
    "\n",
    "# Optional: Save updated dataset\n",
    "# ds.to_netcdf(\"ndvi_centered_from_ref.nc\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ds.keys"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import xarray as xr\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import plotly.graph_objects as go\n",
    "\n",
    "# Load the NDVI data\n",
    "# ds = xr.open_dataset(\"NDVI_HE.netcdf\")\n",
    "# ndvi = ds\n",
    "\n",
    "# Two-step interpolation\n",
    "# new_times = pd.date_range(\"2023-01-01\", \"2023-12-31 23:30:00\", freq=\"30min\")\n",
    "\n",
    "\n",
    "# Interpolate and fill\n",
    "# ndvi_pixel_interp = ndvi.interp(time=new_times, method=\"linear\")\n",
    "# ndvi_interp_full = ndvi_pixel_interp.ffill(\"time\").bfill(\"time\")\n",
    "\n",
    "# Extract coordinates and time\n",
    "x_coords = ds[\"x_meters_from_ref\"].values\n",
    "y_coords = ds[\"y_meters_from_ref\"].values\n",
    "times = ds[\"time\"].values\n",
    "\n",
    "# Sample every 48 time steps (i.e., 1 per day)\n",
    "sample_indices = np.arange(0, len(times), 48)\n",
    "\n",
    "# Create frames\n",
    "frames = []\n",
    "for i in sample_indices:\n",
    "    frames.append(go.Frame(\n",
    "        data=[go.Heatmap(\n",
    "            z=ds['NDVI'][i].values,\n",
    "            x=x_coords,\n",
    "            y=y_coords,\n",
    "            colorscale='Viridis',\n",
    "            zmin=-1,\n",
    "            zmax=1,\n",
    "            colorbar=dict(title='NDVI')\n",
    "        )],\n",
    "        name=str(np.datetime_as_string(times[i], unit='D'))\n",
    "    ))\n",
    "\n",
    "# Create the figure\n",
    "fig = go.Figure(\n",
    "    data=frames[0].data,\n",
    "    layout=go.Layout(\n",
    "        title='NDVI Heatmap Over Time (Interpolated)',\n",
    "        updatemenus=[dict(\n",
    "            type='buttons',\n",
    "            showactive=False,\n",
    "            buttons=[dict(label='Play',\n",
    "                          method='animate',\n",
    "                          args=[None, dict(frame=dict(duration=200, redraw=True),\n",
    "                                           fromcurrent=True, mode='immediate')])]\n",
    "        )],\n",
    "        sliders=[dict(\n",
    "            steps=[dict(method='animate',\n",
    "                        args=[[f.name], dict(mode='immediate',\n",
    "                                             frame=dict(duration=200, redraw=True),\n",
    "                                             fromcurrent=True)],\n",
    "                        label=f.name) for f in frames],\n",
    "            x=0.1,\n",
    "            xanchor=\"left\",\n",
    "            y=0,\n",
    "            yanchor=\"top\"\n",
    "        )]\n",
    "    ),\n",
    "    frames=frames\n",
    ")\n",
    "\n",
    "fig.update_layout(\n",
    "    xaxis_title=\"X Coordinate\",\n",
    "    yaxis_title=\"Y Coordinate\"\n",
    ")\n",
    "\n",
    "fig.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ds.to_netcdf('ndvi_30min_HW_tower_coord_2022_23.netcdf')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "ds['time'][-1]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Plotting NDVI vs GPP"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import xarray as xr\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# === Load GPP data ===\n",
    "gpp_df = pd.read_csv(\"Dataset_HE.csv\", parse_dates=[\"TIMESTAMP\"], index_col=\"TIMESTAMP\")\n",
    "gpp_df = gpp_df[[\"GPP\"]].dropna()\n",
    "gpp_2023 = gpp_df[\"2023-01-01\":\"2023-12-31\"]\n",
    "\n",
    "# === Load NDVI data ===\n",
    "ndvi_ds = xr.open_dataset(\"ndvi_interp_30min_HE.netcdf\")\n",
    "ndvi_mean = ndvi_ds[\"NDVI\"].mean(dim=[\"x\", \"y\"])  # mean over field\n",
    "ndvi_mean_df = ndvi_mean.to_dataframe(name=\"NDVI\").dropna()\n",
    "ndvi_resampled = ndvi_mean_df.resample(\"30T\").mean()\n",
    "\n",
    "# === Resample GPP ===\n",
    "gpp_resampled = gpp_2023.resample(\"30T\").mean()\n",
    "\n",
    "# === Daily aggregates ===\n",
    "daily_max_gpp = gpp_resampled.resample(\"D\").mean()\n",
    "daily_mean_ndvi = ndvi_resampled.resample(\"D\").median()\n",
    "\n",
    "# === Merge ===\n",
    "daily_combined = daily_max_gpp.join(daily_mean_ndvi, how=\"inner\")\n",
    "\n",
    "# === Plot with dual axes ===\n",
    "fig, ax1 = plt.subplots(figsize=(15, 5))\n",
    "\n",
    "# Primary axis: GPP\n",
    "ax1.plot(daily_combined.index, daily_combined[\"GPP\"], label=\"Daily Max GPP\", color='tab:blue')\n",
    "ax1.set_xlabel(\"Date\")\n",
    "ax1.set_ylabel(\"Daily Max GPP\", color='tab:blue')\n",
    "ax1.tick_params(axis='y', labelcolor='tab:blue')\n",
    "ax1.grid(True)\n",
    "\n",
    "# Secondary axis: NDVI\n",
    "ax2 = ax1.twinx()\n",
    "ax2.plot(daily_combined.index, daily_combined[\"NDVI\"], label=\"Daily Mean NDVI\", color='tab:green')\n",
    "ax2.set_ylabel(\"Daily Mean NDVI\", color='tab:green')\n",
    "ax2.tick_params(axis='y', labelcolor='tab:green')\n",
    "\n",
    "# Title and layout\n",
    "plt.title(\"Daily Mean GPP and Daily Median NDVI - 2023 (Dual Axis)\")\n",
    "fig.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import xarray as xr\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# === Load GPP data ===\n",
    "gpp_df = pd.read_csv(\"Dataset_HE.csv\", parse_dates=[\"STARTING_DATETIME\"], index_col=\"STARTING_DATETIME\")\n",
    "gpp_df = gpp_df[[\"GPP\"]].dropna()\n",
    "gpp_2023 = gpp_df[\"2023-01-01\":\"2023-12-31\"]\n",
    "\n",
    "# === Load NDVI data ===\n",
    "ndvi_ds = xr.open_dataset(\"ndvi_interp_30min_HE.netcdf\")\n",
    "ndvi_mean = ndvi_ds[\"NDVI\"].median(dim=[\"x\", \"y\"])  # mean over field\n",
    "ndvi_mean_df = ndvi_mean.to_dataframe(name=\"NDVI\").dropna()\n",
    "ndvi_resampled = ndvi_mean_df.resample(\"30T\").mean()\n",
    "\n",
    "# === Resample GPP ===\n",
    "gpp_resampled = gpp_2023.resample(\"30T\").mean()\n",
    "\n",
    "# === Daily aggregates ===\n",
    "daily_max_gpp = gpp_resampled.resample(\"14D\").mean()\n",
    "daily_mean_ndvi = ndvi_resampled.resample(\"14D\").median()\n",
    "\n",
    "# === Merge ===\n",
    "daily_combined = daily_max_gpp.join(daily_mean_ndvi, how=\"inner\")\n",
    "\n",
    "# === Plot with dual axes ===\n",
    "fig, ax1 = plt.subplots(figsize=(15, 5))\n",
    "\n",
    "# Primary axis: GPP\n",
    "ax1.plot(daily_combined.index, daily_combined[\"GPP\"], label=\"Daily Max GPP\", color='tab:blue')\n",
    "ax1.set_xlabel(\"Date\")\n",
    "ax1.set_ylabel(\"Daily Mean GPP\", color='tab:blue')\n",
    "ax1.tick_params(axis='y', labelcolor='tab:blue')\n",
    "ax1.grid(True)\n",
    "\n",
    "# Secondary axis: NDVI\n",
    "ax2 = ax1.twinx()\n",
    "ax2.plot(daily_combined.index, daily_combined[\"NDVI\"], label=\"Daily Mean NDVI\", color='tab:green')\n",
    "ax2.set_ylabel(\"Daily Mean NDVI\", color='tab:green')\n",
    "ax2.tick_params(axis='y', labelcolor='tab:green')\n",
    "\n",
    "# Title and layout\n",
    "plt.title(\"GPP vs NDVI - 2023 (14 Days Aggregated)\")\n",
    "fig.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import xarray as xr\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "from scipy.stats import pearsonr\n",
    "\n",
    "# === Load GPP data ===\n",
    "gpp_df = pd.read_csv(\"Dataset_HE.csv\", parse_dates=[\"STARTING_DATETIME\"], index_col=\"STARTING_DATETIME\")\n",
    "gpp_df = gpp_df[[\"GPP\"]].dropna()\n",
    "gpp_2023 = gpp_df[\"2023-01-01\":\"2023-12-31\"]\n",
    "\n",
    "# === Load NDVI data ===\n",
    "ndvi_ds = xr.open_dataset(\"ndvi_interp_30min_HE.netcdf\")\n",
    "ndvi_mean = ndvi_ds[\"NDVI\"].median(dim=[\"x\", \"y\"])  # mean over field\n",
    "ndvi_mean_df = ndvi_mean.to_dataframe(name=\"NDVI\").dropna()\n",
    "ndvi_resampled = ndvi_mean_df.resample(\"30T\").mean()\n",
    "\n",
    "# === Resample GPP ===\n",
    "gpp_resampled = gpp_2023.resample(\"30T\").mean()\n",
    "\n",
    "# === Daily aggregates ===\n",
    "daily_max_gpp = gpp_resampled.resample(\"D\").mean()\n",
    "daily_mean_ndvi = ndvi_resampled.resample(\"D\").mean()\n",
    "\n",
    "# === Merge ===\n",
    "daily_combined = daily_max_gpp.join(daily_mean_ndvi, how=\"inner\")\n",
    "\n",
    "# === Correlation ===\n",
    "corr, p_value = pearsonr(daily_combined[\"NDVI\"], daily_combined[\"GPP\"])\n",
    "\n",
    "# === Best fit line ===\n",
    "x = daily_combined[\"NDVI\"].values\n",
    "y = daily_combined[\"GPP\"].values\n",
    "slope, intercept = np.polyfit(x, y, deg=1)\n",
    "line = slope * x + intercept\n",
    "\n",
    "# === Scatter plot with best fit ===\n",
    "plt.figure(figsize=(8, 6))\n",
    "plt.scatter(x, y, alpha=0.6, label=\"Data points\")\n",
    "plt.plot(x, line, color=\"red\", linewidth=2, label=f\"Best fit line\\ny = {slope:.2f}x + {intercept:.2f}\")\n",
    "plt.xlabel(\"Daily mean NDVI (median over area)\")\n",
    "plt.ylabel(\"Daily mean GPP micromol/m2/s\")\n",
    "plt.title(f\"GPP vs NDVI (2023)\\nPearson r = {corr:.2f}, p = {p_value:.2e}\")\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import hvplot.xarray\n",
    "import hvplot.pandas"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ndvi_ds.hvplot.box('NDVI', by=['time'], rot=90, box_fill_color='lightblue', width=900, height=450).opts(ylim=(-0.5,1.5)).opts(title='HE NDVI Timeseries')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import xarray as xr\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# === Load GPP data ===\n",
    "gpp_df = pd.read_csv(\"Dataset_HE.csv\", parse_dates=[\"TIMESTAMP\"], index_col=\"TIMESTAMP\")\n",
    "gpp_df = gpp_df[[\"GPP\"]].dropna()\n",
    "gpp_2023 = gpp_df[\"2023-01-01\":\"2023-12-31\"]\n",
    "\n",
    "# === Load NDVI data ===\n",
    "ndvi_ds = xr.open_dataset(\"ndvi_interp_30min_HE.netcdf\")\n",
    "ndvi_mean = ndvi_ds[\"NDVI\"].mean(dim=[\"x\", \"y\"])\n",
    "ndvi_mean_df = ndvi_mean.to_dataframe(name=\"NDVI\").dropna()\n",
    "ndvi_resampled = ndvi_mean_df.resample(\"30T\").mean()\n",
    "\n",
    "# === Resample GPP to match NDVI ===\n",
    "gpp_resampled = gpp_2023.resample(\"30T\").mean()\n",
    "\n",
    "# === Daily Aggregates ===\n",
    "daily_max_gpp = gpp_resampled.resample(\"D\").max()\n",
    "daily_mean_ndvi = ndvi_resampled.resample(\"D\").mean()\n",
    "\n",
    "# === Merge ===\n",
    "daily_combined = daily_max_gpp.join(daily_mean_ndvi, how=\"inner\")\n",
    "\n",
    "# === Apply 10-Day Rolling Mean on GPP ===\n",
    "daily_combined[\"GPP_10day_avg\"] = daily_combined[\"GPP\"].rolling(window=14, min_periods=1).mean()\n",
    "\n",
    "# === Plot with dual axes ===\n",
    "fig, ax1 = plt.subplots(figsize=(15, 5))\n",
    "\n",
    "# Left axis: Smoothed GPP\n",
    "ax1.plot(daily_combined.index, daily_combined[\"GPP_10day_avg\"], label=\"10-Day Rolling Avg GPP\", color='tab:blue')\n",
    "ax1.set_xlabel(\"Date\")\n",
    "ax1.set_ylabel(\"10-Day Avg GPP\", color='tab:blue')\n",
    "ax1.tick_params(axis='y', labelcolor='tab:blue')\n",
    "ax1.grid(True)\n",
    "\n",
    "# Right axis: NDVI\n",
    "ax2 = ax1.twinx()\n",
    "ax2.plot(daily_combined.index, daily_combined[\"NDVI\"], label=\"Daily Mean NDVI\", color='tab:green')\n",
    "ax2.set_ylabel(\"Daily Mean NDVI\", color='tab:green')\n",
    "ax2.tick_params(axis='y', labelcolor='tab:green')\n",
    "\n",
    "# Title and layout\n",
    "plt.title(\"14-Day Rolling Avg GPP and Daily Mean NDVI - 2023\")\n",
    "fig.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "gpp_df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Overlay Grazing on NDVI"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import xarray as xr\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Load the CSV and NetCDF files\n",
    "df_graze_raw = pd.read_csv(\"FSW_GRAZE_EFFECTED.csv\")\n",
    "df_graze = df_graze_raw.rename(columns={'STARTING_DATETIME': 'START_DATETIME'})\n",
    "df_graze['START_DATETIME'] = pd.to_datetime(df_graze['START_DATETIME'])\n",
    "\n",
    "# Filter only grazing-affected events\n",
    "df_graze_filtered = df_graze[df_graze_raw['GRAZING_EFFECTED'] == 1]\n",
    "\n",
    "# Drop duplicate grazing dates to avoid excessive vertical lines\n",
    "unique_graze_dates = df_graze_filtered['START_DATETIME'].drop_duplicates()\n",
    "\n",
    "# Load NDVI from NetCDF\n",
    "ds = xr.open_dataset(\"NDVI_Ferguson_only_grass_Interpolated.netcdf\")\n",
    "ndvi_mean = ds['NDVI'].mean(dim=['x', 'y'])\n",
    "\n",
    "# Plotting\n",
    "plt.figure(figsize=(15, 5))\n",
    "ndvi_mean.plot(label='Mean NDVI', color='green')\n",
    "\n",
    "# Overlay vertical lines for unique grazing dates\n",
    "for date in unique_graze_dates:\n",
    "    plt.axvline(x=date, color='red', alpha=0.1)\n",
    "\n",
    "plt.title('Mean NDVI Time Series with Grazing-Affected Events')\n",
    "plt.xlabel('Time')\n",
    "plt.ylabel('Mean NDVI')\n",
    "plt.legend()\n",
    "plt.grid(True)\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_graze_raw"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import xarray as xr\n",
    "\n",
    "df = xr.load_dataset('NDVI_Ferguson_only_grass_Interpolated.netcdf')\n",
    "ndvi_mean = df['NDVI'].mean(dim=['x', 'y'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "plt.plot(ndvi_mean)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Overlay Grazing on GPP"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Load dataset\n",
    "dataset_fsw = pd.read_csv(\"Dataset_FNE.csv\")\n",
    "dataset_fsw['TIMESTAMP'] = pd.to_datetime(dataset_fsw['TIMESTAMP'])\n",
    "\n",
    "# Load grazing start and end dates\n",
    "grazing_start = pd.read_parquet(\"Ferguson_start.parquet\")\n",
    "grazing_end = pd.read_parquet(\"Ferguson_end.parquet\")\n",
    "grazing_start['Time_30min'] = pd.to_datetime(grazing_start['Time_30min'])\n",
    "grazing_end['Time_30min'] = pd.to_datetime(grazing_end['Time_30min'])\n",
    "\n",
    "# Resample GPP to daily mean\n",
    "daily_gpp = dataset_fsw.set_index('TIMESTAMP').resample('D').mean(numeric_only=True)['GPP']\n",
    "daily_gpp_2023 = daily_gpp[daily_gpp.index.year == 2023]\n",
    "\n",
    "# Plot GPP time series with grazing periods\n",
    "plt.figure(figsize=(15, 5))\n",
    "plt.plot(daily_gpp_2023.index, daily_gpp_2023.values, label='Daily GPP (2023)', color='green')\n",
    "\n",
    "# Overlay vertical lines for grazing periods\n",
    "for start, end in zip(grazing_start['DATE'], grazing_end['DATE']):\n",
    "    if start.year == 2023:\n",
    "        plt.axvspan(start, end, color='gray', alpha=0.3, label='Grazing Period' if start == grazing_start['Time_30min'].iloc[0] else \"\")\n",
    "\n",
    "plt.xlabel(\"Date\")\n",
    "plt.ylabel(\"GPP (µmol m⁻² s⁻¹)\")\n",
    "plt.title(\"Daily GPP in 2023 with Grazing Periods (FSW)\")\n",
    "plt.grid(True)\n",
    "plt.legend()\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "grazing_start = pd.read_parquet(\"Ferguson_start.parquet\")\n",
    "grazing_end = pd.read_parquet(\"Ferguson_end.parquet\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "grazing_start.columns"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "rb",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.17"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
